<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WALL OF FAME | SSALE</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=Staatliches&display=swap" rel="stylesheet"/>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    /* Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Base */
    body {
      background-color: #000;
      color: white;
      font-family: "Inter", sans-serif;
      height: 500vh;
      overflow-x: hidden;
      letter-spacing: -0.02em;
      scroll-behavior: smooth;
    }

    /* Layout */
    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .tweakpane-container {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: none;
    }

    /* Title Section */
    .title-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 800px;
      text-align: center;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: opacity 1.2s ease, visibility 0s 1.2s;
      pointer-events: none;
    }

    .title-container.visible {
      opacity: 1;
      visibility: visible;
      transition: opacity 1.2s ease, visibility 0s;
      pointer-events: auto;
    }

    /* Typography */
    h1 {
      font-family: "Staatliches", sans-serif;
      font-size: 8rem;
      line-height: 0.9;
      letter-spacing: -0.02em;
      text-transform: uppercase;
      margin-bottom: 1rem;
    }

    h2 {
      font-family: "Staatliches", sans-serif;
      font-size: 2rem;
      line-height: 1;
      letter-spacing: 0.05em;
      margin: 0 auto 3rem;
      max-width: 600px;
    }

    .cta-btn {
      display: block;
      margin: 2rem auto 0 auto;
      padding: 1rem 2.5rem;
      font-size: 1.3rem;
      max-width: 200px;
      font-family: "Staatliches", sans-serif;
      background: #ff3030;
      color: #fff;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
      box-shadow: 0 4px 24px rgba(0,0,0,0.12);
    }
    .cta-btn:hover {
      background: #ff6000;
      transform: scale(1.05);
    }
    .logo-style {
      max-width: 320px;
      width: 60vw;
      height: auto;
      margin-bottom: 2rem;
    }
    @media (max-width: 600px) {
      .logo-style {
        width: 90vw;
        max-width: 200px;
        margin-bottom: 1.2rem;
      }
      .cta-btn {
        font-size: 1rem;
        padding: 0.8rem 1.8rem;
      }
      .subtitle {
        font-size: 3.0rem;
      }
    }

    .header .nav-section a {
      text-decoration: none !important;
      background: none !important;
      color: inherit !important;
      font-family: inherit !important;
      font-size: inherit !important;
      font-weight: inherit !important;
      letter-spacing: inherit !important;
      box-shadow: none !important;
      transition: none !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .header .nav-section a::after {
      display: none !important;
      content: none !important;
    }

    /* Narration System */
    .narration-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 800px;
      z-index: 199;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .narration-container.visible {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    .narration-text {
      text-align: center;
      margin-bottom: 2rem;
      font-weight: 300;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
      width: 100%;
    }

    .narration-text.cta-active {
      margin-bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .narration-text h1 {
      font-family: "Staatliches", sans-serif;
      font-size: clamp(2.5rem, 8vw, 4.5rem);
      line-height: 1.1;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .narration-text h3 {
      font-family: "Staatliches", sans-serif;
      font-size: clamp(1.2rem, 4vw, 2rem);
      line-height: 1.2;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .narration-text p {
      font-size: clamp(1rem, 3vw, 1.4rem);
      line-height: 1.5;
      margin: 0;
      font-weight: 300;
    }

    /* Progress bar styles */
    .progress-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      z-index: 1000;
      display: none;
    }

    .progress-bar {
      height: 100%;
      background: #ff3c3c;
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
    }

    .progress-percentage {
      position: absolute;
      right: 0;
      top: -25px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: "Inter", sans-serif;
      opacity: 1;
      transition: none;
      pointer-events: auto;
      white-space: nowrap;
    }

    @media (max-width: 768px) {
      .progress-percentage {
        font-size: 10px;
        top: -20px;
      }
    }

    @media (max-width: 480px) {
      .narration-container {
        padding: 0.5rem;
      }
      
      .narration-text {
        margin-bottom: 1rem;
      }
    }

    body.bg-end {
      background-color: #000 !important;
      opacity: 1 !important;
      z-index: 99999 !important;
    }

    #container:not(.bg-end) {
      background: none;
      opacity: 1;
    }

    /* Add new animated pulse button styles */
    .button-pulse {
      position: relative;
      margin: 85px auto 0;
      max-width: 200px;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 201;
    }
    .button__wrapper {
      position: relative;
      width: 200px;
      height: 55px;
      top: -50px;
    }
    .button-pulse #continue-btn {
      cursor: pointer;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      z-index: 202;
      padding: 8px;
      font-size: 20px;
      border: 2px solid rgb(243 197 48 / 70%);
      background-color: rgb(214 139 139);
      background-image: linear-gradient(to right, #7d0633, rgb(223 117 100));
      color: #fff;
      font-weight: 700;
      transition: box-shadow 0.5s;
      font-family: inherit;
      border-radius: 60px;
      pointer-events: auto;
    }
    .pulsing {
      width: 99%;
      height: 99%;
      border-radius: 50px;
      z-index: 1;
      position: relative;
    }
    .pulsing:before, .pulsing:after {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      border: inherit;
      top: 0;
      left: 0;
      z-index: 0;
      background: rgb(214 148 33 / 41%);
      border-radius: inherit;
      animation: pulsing 1s linear infinite;
    }
    .pulsing:after {
      animation: pulsing1 1s linear infinite;
    }
    @keyframes pulsing {
      0% { opacity: 1; transform: scaleY(1) scaleX(1); }
      20% { opacity: 0.7; }
      70% { opacity: 0.5; transform: scaleY(1.8) scaleX(1.3); }
      80% { opacity: 0; transform: scaleY(1.8) scaleX(1.3); }
      90% { opacity: 0; transform: scaleY(1) scaleX(1); }
    }
    @keyframes pulsing1 {
      0% { opacity: 1; transform: scaleY(1) scaleX(1); }
      20% { opacity: 0.7; }
      70% { opacity: 0.5; transform: scaleY(1.3) scaleX(1.15); }
      80% { opacity: 0; transform: scaleY(1.3) scaleX(1.15); }
      90% { opacity: 0; transform: scaleY(1) scaleX(1); }
    }
    .button-pulse #continue-btn:hover,
    .button-pulse #continue-btn:focus {
      outline: none;
      border: none;
    }

    #narration-img-main {
      max-width: 80vw;
      max-height: 25vh;
      display: block;
      margin: 0 auto;
    }
    @media (max-width: 600px) {
      #narration-img-main {
        max-height: 35vh !important;
      }
    }

    .narration-img-stack {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .swipe-indicator {
      margin-top: 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .swipe-text {
    color: #fefcee;
    font-family: monospace;
    font-size: 1.3rem;
    margin-top: 10px;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }
    @media (max-width: 600px) {
      .swipe-text {
        font-size: 1rem;
      }
      .swipe-indicator svg {
        width: 40px !important;
        height: 24px !important;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="tunnel"></canvas>
  </div>

  <!-- Progress bar container -->
  <div class="progress-container">
    <div class="progress-bar" id="progress-bar">
      <span class="progress-percentage" id="progress-percentage">0%</span>
    </div>
  </div>

  <!-- Narration container -->
  <div class="narration-container visible" id="narration-container">
    <div class="narration-text" id="narration-text"></div>
  </div>

  <!-- Title and subtitle container -->
  <div class="title-container" id="title-container">
    <div class="button-pulse">
      <div class="button__wrapper scale">
        <div class="pulsing"></div>
        <a href="./pages/wall.html">
          <button id="continue-btn">Click here to enter</button>
        </a>
      </div>
    </div>
  </div>

  <!-- Tweakpane container -->
  <div class="tweakpane-container" id="tweakpane-container"></div>

  <!-- GSAP and ScrollTrigger -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
  <!-- Add GSAP ScrollToPlugin CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollToPlugin.min.js"></script>

  <!-- Main Script -->
  <script type="module">
    // Import modules
import * as THREE from "https://esm.sh/three@0.175.0";
import { Pane } from "https://cdn.skypack.dev/tweakpane@4.0.4";
import Stats from "https://esm.sh/stats.js@0.17.0";
import { EffectComposer } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/UnrealBloomPass.js";

// Register ScrollTrigger and ScrollToPlugin
gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);

// Detect device capabilities for performance optimization
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
);
const isLowEndDevice =
  isMobile ||
  (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) ||
  (navigator.deviceMemory && navigator.deviceMemory <= 4);

// Color presets
const colorPresets = {
  default: {
    colorA: "#ff3030", // Start of tunnel
    colorB: "#ff6000", // After first quarter
    colorC: "#ffcf00", // After second quarter
    colorD: "#ffec7f" // End of tunnel
  },
  "dark-abyss": {
    colorA: "#0a0a2a", // Deep dark blue
    colorB: "#1a1a4a", // Dark blue
    colorC: "#3a1a6a", // Dark purple
    colorD: "#0a0a1a" // Almost black
  },
  "neon-dreams": {
    colorA: "#ff00ff", // Neon pink
    colorB: "#00ff99", // Neon green
    colorC: "#ff3399", // Bright pink
    colorD: "#9900ff" // Neon purple
  },
  "golden-hour": {
    colorA: "#ff7700", // Bright orange
    colorB: "#ff3300", // Reddish orange
    colorC: "#ffaa00", // Golden yellow
    colorD: "#ff0000" // Deep red
  },
  "deep-ocean": {
    colorA: "#006699", // Deep blue
    colorB: "#00aacc", // Turquoise
    colorC: "#006666", // Teal
    colorD: "#003366" // Navy blue
  },
  "aurora-borealis": {
    colorA: "#00cc99", // Green
    colorB: "#6600cc", // Purple
    colorC: "#00ffcc", // Bright green
    colorD: "#3300ff" // Deep blue
  }
};

// Parameters
const params = {
  // Structure
  tunnelDepth: 30,
  circleCount: 60,
  tunnelRadius: 3,
  tubeThickness: 0.5,
  circleSegments: 64,
  tubeSegments: 6,
  pathAmplitude: 0.5,

  // Appearance
  colorA: "#ff3030",
  colorB: "#ff6000",
  colorC: "#ffcf00",
  colorD: "#ffec7f",
  emission: 0.1,
  metalness: 0.7,
  roughness: 0.4,
  fogDensity: 0.065,

  // Effects
  pulseSpeed: 4.7,
  pulseIntensity: 0.8,
  rotationSpeed: 0.011,
  particlesEnabled: false,
  particleCount: 0,
  particleSize: 0.04,
  particleSpeed: 0.5,

  // Stars
  starsEnabled: true,
  starCount: 1000,
  starSize: 0.05,

  // Movement
  autoMovement: true,
  manualPosition: 0,
  scrollSpeed: 1,
  fadeStart: 0.85,
  fadeIntensity: 3,

  // Performance
  qualityPreset: "high",
  useBloom: true,

  // Presets
  colorPreset: "default",

  // Title settings
  titleShowThreshold: 0.95,
  titleHideThreshold: 0.93,

  // Narration settings
  narrationPoints: [
    {
      progress: 0.01,
      text: `
        <div class="narration-img-stack">
          <img src="svg/Text 1.png" alt="Welcome to Shoppers Stop" style="max-width:80vw;max-height:25vh;display:block;margin:0 auto;" id="narration-img-main" />
          <div class="swipe-indicator">
            <svg width="60" height="40" viewBox="0 0 60 40" fill="none" xmlns="http://www.w3.org/2000/svg" style="display:block;margin:0 auto;">
              <polyline points="15,25 30,10 45,25" stroke="#ff3c3c" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
              <polyline points="15,35 30,20 45,35" stroke="#ff3c3c" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <div class="swipe-text">swipe up to enter</div>
          </div>
        </div>
      `
    },
    {
      progress: 0.18,
      text: `<img src="svg/text2.png" alt="Narration 2" style="max-width:80vw;max-height:35vh;display:block;margin:0 auto;" />`
    },
    {
      progress: 0.52,
      text: `<div style="display:flex;justify-content:center;align-items:center;height:100vh;width:100%;"><img src="svg/text4.png" alt="Narration 4" style="max-width:80vw;max-height:25vh;display:block;" /></div>`
    },
    {
      progress: 0.85,
      text: `<div class='button-pulse' style='margin-top: 0;'><div class='button__wrapper scale'><div class='pulsing'></div><a href='./pages/wall.html'><button id='continue-btn'>Click here to enter</button></a></div></div>`
    }
  ],
  narrationShowThreshold: 0.01,
  narrationHideThreshold: 0.95,

  // Swipe instruction settings
  swipeShowDuration: 5000, // Show for 5 seconds total
  swipeFadeInDuration: 1000, // Fade in over 1 second
  swipeFadeOutDuration: 1000, // Fade out over 1 second
  swipePulseDuration: 2000, // Each pulse cycle duration
};

// Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, params.fogDensity);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("tunnel"),
  antialias: !isLowEndDevice,
  powerPreference: "high-performance"
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;

// Setup post-processing with bloom
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

// Add bloom effect
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.2, // Bloom strength
  0.5, // Bloom radius
  0.3 // Bloom threshold
);
composer.addPass(bloomPass);

// Stats
const stats = new Stats();
stats.showPanel(0);
document.body.appendChild(stats.dom);
stats.dom.style.display = 'none';

// Add lights
const ambientLight = new THREE.AmbientLight(0x404040, 1);
scene.add(ambientLight);

const light1 = new THREE.PointLight(0xff3030, 2, 50);
light1.position.set(0, 0, 10);
scene.add(light1);

const light2 = new THREE.PointLight(0xff6000, 2, 50);
light2.position.set(0, 0, -20);
scene.add(light2);

// Object pool for geometry reuse
const geometryPool = {
  torus: {}
};

// Get or create torus geometry from pool
function getTorusGeometry(radius, tubeThickness, tubeSegments, circleSegments) {
  const key = `${radius}-${tubeThickness}-${tubeSegments}-${circleSegments}`;
  if (!geometryPool.torus[key]) {
    geometryPool.torus[key] = new THREE.TorusGeometry(
      radius,
      tubeThickness,
      tubeSegments,
      circleSegments
    );
  }
  return geometryPool.torus[key];
}

// Create tunnel path
function createPath() {
  const path = [];
  const segments = 100;

  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const z = -t * params.tunnelDepth;

    // Sine wave path for more interest
    const x = Math.sin(t * 10) * params.pathAmplitude;
    const y = Math.cos(t * 8) * params.pathAmplitude;

    path.push(new THREE.Vector3(x, y, z));
  }

  return new THREE.CatmullRomCurve3(path);
}

let tunnelPath = createPath();

// Group for all circles
let tunnelGroup = new THREE.Group();
scene.add(tunnelGroup);

// Particle system for floating dust
let particles;
let particleTexture;

// Star field
let starField;
let starTexture;

// Tunnel end particles (gold, red, white celebratory particles)
let tunnelEndParticles = null;
let tunnelEndParticlesGeometry = null;
let tunnelEndParticlesGroup = new THREE.Group();
scene.add(tunnelEndParticlesGroup);

// Create a circular particle texture (only once)
function createParticleTexture() {
  if (particleTexture) return particleTexture;

  const canvas = document.createElement("canvas");
  canvas.width = 32;
  canvas.height = 32;

  const context = canvas.getContext("2d");
  const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
  gradient.addColorStop(0, "rgba(255,255,255,1)");
  gradient.addColorStop(1, "rgba(255,255,255,0)");

  context.fillStyle = gradient;
  context.fillRect(0, 0, 32, 32);

  particleTexture = new THREE.Texture(canvas);
  particleTexture.needsUpdate = true;
  return particleTexture;
}

// Create a star texture (only once)
function createStarTexture() {
  if (starTexture) return starTexture;

  const canvas = document.createElement("canvas");
  canvas.width = 32;
  canvas.height = 32;

  const context = canvas.getContext("2d");
  const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
  gradient.addColorStop(0, "rgba(255,255,255,1)");
  gradient.addColorStop(0.4, "rgba(200,220,255,0.8)");
  gradient.addColorStop(1, "rgba(200,220,255,0)");

  context.fillStyle = gradient;
  context.fillRect(0, 0, 32, 32);

  starTexture = new THREE.Texture(canvas);
  starTexture.needsUpdate = true;
  return starTexture;
}

// Create star field (background stars, no warp effect)
function createStarField() {
  if (starField) scene.remove(starField);

  if (!params.starsEnabled) return;

  const starGeo = new THREE.BufferGeometry();
  const starPositions = [];
  const starSizes = [];
  const starColors = [];

  // Create stars in a spherical distribution around the tunnel
  const sphereRadius = 100; // Large radius to place stars far away

  for (let i = 0; i < params.starCount; i++) {
    // Random spherical coordinates
    const theta = Math.random() * Math.PI * 2; // Azimuthal angle
    const phi = Math.acos(2 * Math.random() - 1); // Polar angle

    // Convert to Cartesian coordinates
    const x = sphereRadius * Math.sin(phi) * Math.cos(theta);
    const y = sphereRadius * Math.sin(phi) * Math.sin(theta);
    const z = sphereRadius * Math.cos(phi);

    starPositions.push(x, y, z);

    // Random size variation
    const size = params.starSize * (0.5 + Math.random() * 0.5);
    starSizes.push(size);

    // Slightly varied white/blue colors for stars
    const r = 0.8 + Math.random() * 0.2;
    const g = 0.8 + Math.random() * 0.2;
    const b = 0.9 + Math.random() * 0.1;
    starColors.push(r, g, b);
  }

  // Set attributes
  starGeo.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(starPositions, 3)
  );
  starGeo.setAttribute(
    "color",
    new THREE.Float32BufferAttribute(starColors, 3)
  );
  starGeo.setAttribute("size", new THREE.Float32BufferAttribute(starSizes, 1));

  // Create material with custom shader for better star rendering
  const starMaterial = new THREE.PointsMaterial({
    size: params.starSize,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
    map: createStarTexture(),
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  starField = new THREE.Points(starGeo, starMaterial);
  scene.add(starField);
}

// Create particles
function createParticles() {
  if (particles) scene.remove(particles);

  if (!params.particlesEnabled) return;

  const particleGeo = new THREE.BufferGeometry();
  const particlePositions = [];
  const particleColors = [];
  const particleVelocities = [];
  
  const colorA = new THREE.Color(params.colorA);
  const colorB = new THREE.Color(params.colorB);
  const colorC = new THREE.Color(params.colorC);
  const colorD = new THREE.Color(params.colorD);

  for (let i = 0; i < params.particleCount; i++) {
    // Random position within tunnel volume
    const t = Math.random();
    const ringRadius = params.tunnelRadius * (0.5 + Math.random() * 0.5); // Vary radius
    const angle = Math.random() * Math.PI * 2;

    // Calculate position on path
    const pathPoint = tunnelPath.getPointAt(t);

    // Random position within tube radius
    const x = pathPoint.x + Math.cos(angle) * ringRadius;
    const y = pathPoint.y + Math.sin(angle) * ringRadius;
    const z = pathPoint.z;

    particlePositions.push(x, y, z);

    // Random velocities for movement
    particleVelocities.push(
      (Math.random() - 0.5) * 0.01,
      (Math.random() - 0.5) * 0.01,
      (Math.random() - 0.5) * 0.01
    );

    // Blend colors based on position in tunnel
    let color;
    if (t < 0.25) {
      color = new THREE.Color().lerpColors(colorA, colorB, t * 4);
    } else if (t < 0.5) {
      color = new THREE.Color().lerpColors(colorB, colorC, (t - 0.25) * 4);
    } else if (t < 0.75) {
      color = new THREE.Color().lerpColors(colorC, colorD, (t - 0.5) * 4);
    } else {
      color = colorD.clone();
    }

    particleColors.push(color.r, color.g, color.b);
  }

  // Set attributes
  particleGeo.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(particlePositions, 3)
  );
  particleGeo.setAttribute(
    "color",
    new THREE.Float32BufferAttribute(particleColors, 3)
  );

  // Create material
  const particleMaterial = new THREE.PointsMaterial({
    size: params.particleSize,
    vertexColors: true,
    transparent: true,
    opacity: 0.6,
    map: createParticleTexture(),
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    alphaTest: 0.01
  });

  particles = new THREE.Points(particleGeo, particleMaterial);
  particles.userData = {
    initialPositions: [...particlePositions], // Clone the initial positions
    velocities: particleVelocities
  };

  scene.add(particles);
}

// Create tunnel end particles
function createTunnelEndParticles() {
  if (tunnelEndParticles) {
    tunnelEndParticlesGroup.remove(tunnelEndParticles);
    tunnelEndParticles.geometry.dispose();
    tunnelEndParticles.material.dispose();
    tunnelEndParticles = null;
  }
  const count = 120;
  tunnelEndParticlesGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  for (let i = 0; i < count; i++) {
    // Spread particles in a much larger sphere to fill the last slide
    const r = 4 + Math.random() * 8;
    const theta = Math.random() * 2 * Math.PI;
    const phi = Math.acos(2 * Math.random() - 1);
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);
    positions[i * 3] = x;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = z;
    // Gold, Red, White
    const colorType = Math.random();
    if (colorType < 0.5) {
      // Gold
      colors[i * 3] = 1; colors[i * 3 + 1] = 0.85; colors[i * 3 + 2] = 0.3;
    } else if (colorType < 0.8) {
      // Red
      colors[i * 3] = 1; colors[i * 3 + 1] = 0.2; colors[i * 3 + 2] = 0.2;
    } else {
      // White
      colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
    }
    sizes[i] = 0.7 + Math.random() * 0.7;
  }
  tunnelEndParticlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  tunnelEndParticlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  tunnelEndParticlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  const tunnelEndParticlesMaterial = new THREE.PointsMaterial({
    size: 0.9,
    vertexColors: true,
    transparent: true,
    opacity: 0.95,
    map: createStarTexture(),
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  tunnelEndParticles = new THREE.Points(tunnelEndParticlesGeometry, tunnelEndParticlesMaterial);
  tunnelEndParticlesGroup.add(tunnelEndParticles);
  tunnelEndParticlesGroup.visible = false;
}

// Add these constants at the top
const FRAME_HEIGHT = window.innerHeight;
const SCROLL_SPEED = 0.8;
let isScrolling = false;
let currentFrame = 0;
const totalFrames = 4;
let time = 0;
let lastFrameTime = 0;
let deltaTime = 0;
let animationFrameId;

// Add easing constants
const EASE_DURATION = 1.2; // Duration of the ease in seconds
const EASE_TYPE = "power2.inOut"; // Smooth ease in and out

// Apple-style smooth scroll variables
let targetFrame = 0;
let currentFrameSmooth = 0;
const LERP_FACTOR_NORMAL = 0.12; // Normal speed
const LERP_FACTOR_SLOW = 0.015;  // Even slower, smoother motion for CTA arrival

// Get DOM elements
const titleContainer = document.getElementById("title-container");
const narrationContainer = document.getElementById("narration-container");
const narrationText = document.getElementById("narration-text");
const progressBar = document.getElementById("progress-bar");

// Create tunnel
createTunnel();

// Animation loop
function animate(currentTime = 0) {
  stats.begin();

  // Add frame rate limiting for mobile devices
  if (isMobile) {
    const frameInterval = 1000 / 30; // Target 30 FPS for mobile
    const elapsed = currentTime - lastFrameTime;
    if (elapsed < frameInterval) {
      stats.end();
      animationFrameId = requestAnimationFrame(animate);
      return;
    }
  }

  deltaTime = Math.min(0.05, (currentTime - lastFrameTime) / 1000);
  lastFrameTime = currentTime;
  time += deltaTime;

  // Simpler lerp for smoother transitions
  currentFrameSmooth += (targetFrame - currentFrameSmooth) * 0.1;
  
  // Calculate tunnel progress based on currentFrameSmooth
  const pathProgress = currentFrameSmooth / (totalFrames - 1);
  const position = tunnelPath.getPointAt(pathProgress);
  camera.position.copy(position);
  const lookAtPosition = tunnelPath.getPointAt(Math.min(pathProgress + 0.01, 0.99));
  camera.lookAt(lookAtPosition);

  // Update narration and progress bar based on rounded frame
  const roundedFrame = Math.round(currentFrameSmooth);
  updateNarrationByIndex(roundedFrame, pathProgress);

  // Move lights with camera
  light1.position.copy(camera.position);
  light1.position.z += 3;

  // Optimize ring animation by only processing visible rings
  if (params.pulseIntensity > 0 || params.rotationSpeed > 0) {
    const visibleRings = tunnelGroup.children.filter(ring => {
      const distanceToCamera = camera.position.distanceTo(ring.position);
      return distanceToCamera <= params.tunnelDepth * 0.5;
    });
    visibleRings.forEach((ring, i) => {
      if (params.pulseIntensity > 0) {
        const pulse = Math.sin(time * params.pulseSpeed + i * 0.2) * params.pulseIntensity;
        if (ring.material.color && ring.material.emissive) {
          const baseEmission = params.emission;
          const emissionColor = ring.material.color.clone().multiplyScalar(baseEmission * (1 + pulse));
          ring.material.emissive.copy(emissionColor);
        }
      }
      if (params.rotationSpeed > 0) {
        ring.rotation.z += params.rotationSpeed * deltaTime * 60 * (1 + Math.sin(i * 0.1) * 0.5);
      }
    });
  }

  // Calculate tunnel fade (1 = fully visible, 0 = fully faded)
  let tunnelFade = 1;
  let narrationFade = 1;
  if (roundedFrame === totalFrames - 1) {
    tunnelFade = 0;
    narrationFade = 0;
  }

  // Apply tunnelFade to tunnel rings
  for (let i = 0; i < tunnelGroup.children.length; i++) {
    const ring = tunnelGroup.children[i];
    if (ring.material) {
      ring.material.opacity = tunnelFade;
      ring.material.transparent = tunnelFade < 1;
      ring.material.depthWrite = tunnelFade === 1;
      ring.material.needsUpdate = true;
    }
  }
  // Apply tunnelFade to particles
  if (particles && particles.material) {
    particles.material.opacity = 0.6 * tunnelFade;
    particles.material.transparent = tunnelFade < 1;
    particles.material.depthWrite = tunnelFade === 1;
    particles.material.needsUpdate = true;
  }
  // Fade fog in sync with tunnel
  scene.fog.density = params.fogDensity * tunnelFade;

  // Fade to black at end (only set background to black when fully faded)
  if (tunnelFade === 0) {
    renderer.setClearColor(0x000000, 1);
    document.body.classList.add('bg-end');
  } else {
    document.body.classList.remove('bg-end');
    renderer.setClearColor(0x282828, 1);
  }

  // Only fade in CTA, no fade out for last text
  const narrationTextEl = document.getElementById('narration-text');
  if (narrationTextEl) {
    // Fade out text4.png over 1s as you approach the CTA
    if (
      roundedFrame === totalFrames - 2 &&
      narrationTextEl.innerHTML.includes('text4.png')
    ) {
      // Fade out as you approach the last frame
      let fade = 1;
      if (currentFrameSmooth > totalFrames - 2) {
        fade = 1 - Math.min(1, currentFrameSmooth - (totalFrames - 2));
      }
      narrationTextEl.style.opacity = fade;
      narrationTextEl.style.transition = 'opacity 1s cubic-bezier(0.4,0,0.2,1)';
    } else if (roundedFrame === totalFrames - 1) {
      narrationTextEl.style.opacity = 0;
      narrationTextEl.style.transition = '';
    } else {
      narrationTextEl.style.opacity = 1;
      narrationTextEl.style.transition = '';
    }
  }
  const ctaBtn = document.querySelector('.button-pulse');
  if (ctaBtn) {
    if (roundedFrame === totalFrames - 1 || currentFrameSmooth >= totalFrames - 1) {
      ctaBtn.style.opacity = 1;
      ctaBtn.style.pointerEvents = 'auto';
      ctaBtn.style.transition = 'opacity 0.8s cubic-bezier(0.4,0,0.2,1)';
    } else if (currentFrameSmooth >= totalFrames - 2) {
      // Fade in as you approach the last frame
      let fade = Math.min(1, currentFrameSmooth - (totalFrames - 2));
      ctaBtn.style.opacity = fade;
      ctaBtn.style.pointerEvents = fade > 0.95 ? 'auto' : 'none';
      ctaBtn.style.transition = 'opacity 0.8s cubic-bezier(0.4,0,0.2,1)';
    } else {
      ctaBtn.style.opacity = 0;
      ctaBtn.style.pointerEvents = 'none';
      ctaBtn.style.transition = 'opacity 0.8s cubic-bezier(0.4,0,0.2,1)';
    }
  }

  // Update title container visibility
  if (titleContainer) {
    if (roundedFrame === totalFrames - 1 || currentFrameSmooth >= totalFrames - 1) {
      titleContainer.classList.add('visible');
    } else {
      titleContainer.classList.remove('visible');
    }
  }

  // Render
  if (params.useBloom) {
    composer.render();
  } else {
    renderer.render(scene, camera);
  }

  stats.end();
  animationFrameId = requestAnimationFrame(animate);
}

// Add particle update function
function updateParticles() {
  if (particles && particles.userData) {
    const positions = particles.geometry.attributes.position.array;
    const velocities = particles.userData.velocities;
    
    for (let i = 0; i < positions.length; i += 3) {
      positions[i] += velocities[i] * params.particleSpeed;
      positions[i + 1] += velocities[i + 1] * params.particleSpeed;
      positions[i + 2] += velocities[i + 2] * params.particleSpeed;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
  }
}

// Function to update narration
function updateNarrationByIndex(index, progress) {
  // Update progress bar
  const percentage = Math.round(progress * 100);
  progressBar.style.width = `${percentage}%`;
  const percentageElement = document.getElementById('progress-percentage');
  if (percentageElement) {
    percentageElement.textContent = `${percentage}%`;
  }

  // Set narration
  const currentPoint = params.narrationPoints[index];
  if (currentPoint && currentPoint.text) {
    narrationText.innerHTML = currentPoint.text;
  }

  // Show/hide narration container
  narrationContainer.classList.add('visible');

  // Add cta-active class for last section
  if (index === params.narrationPoints.length - 1) {
    narrationText.classList.add('cta-active');
  } else {
    narrationText.classList.remove('cta-active');
  }

  // Update narration image for mobile
  updateNarrationImageForMobile();
}

// Update scrollToFrame function
function scrollToFrame(frameIndex) {
  if (frameIndex < 0 || frameIndex >= totalFrames) return;
  targetFrame = frameIndex;
}

// Add touch event handling
let touchStartY = 0;
let touchThreshold = 10; // Very small threshold for easier scrolling

// Simple touch event handling
window.addEventListener('touchstart', (e) => {
  touchStartY = e.touches[0].clientY;
}, { passive: true });

window.addEventListener('touchmove', (e) => {
  const touchY = e.touches[0].clientY;
  const deltaY = touchStartY - touchY;
  
  if (Math.abs(deltaY) > touchThreshold) {
    if (deltaY > 0 && targetFrame < totalFrames - 1) {
      scrollToFrame(targetFrame + 1);
      touchStartY = touchY;
    } else if (deltaY < 0 && targetFrame > 0) {
      scrollToFrame(targetFrame - 1);
      touchStartY = touchY;
    }
  }
}, { passive: true });

// Add wheel event listener for desktop
window.addEventListener('wheel', (e) => {
  if (e.deltaY > 0 && targetFrame < totalFrames - 1) {
    scrollToFrame(targetFrame + 1);
  } else if (e.deltaY < 0 && targetFrame > 0) {
    scrollToFrame(targetFrame - 1);
  }
}, { passive: true });

// Add keyboard navigation
window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowDown' || e.key === 'PageDown') {
    scrollToFrame(targetFrame + 1);
  } else if (e.key === 'ArrowUp' || e.key === 'PageUp') {
    scrollToFrame(targetFrame - 1);
  }
});

// Optimize scroll behavior
document.body.style.overscrollBehavior = 'none';
document.body.style.scrollSnapType = 'y mandatory';
document.body.style.height = `${totalFrames * 100}vh`;
document.body.style.overflow = 'hidden';

// Initialize first frame
scrollToFrame(0);
animate();

// Handle resize
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});

// Define applyQualityPreset before it is used
function applyQualityPreset(preset) {
  switch (preset) {
    case "low":
      params.circleCount = 30; // Reduced from 50
      params.circleSegments = 32; // Reduced from 48
      params.tubeSegments = 4; // Reduced from 6
      params.particlesEnabled = false;
      params.useBloom = false;
      params.starCount = 500; // Reduced from 1000
      renderer.setPixelRatio(1);
      break;
    case "medium":
      params.circleCount = 50; // Reduced from 80
      params.circleSegments = 48; // Reduced from 64
      params.tubeSegments = 6;
      params.particlesEnabled = true;
      params.particleCount = 300; // Reduced from 500
      params.useBloom = true;
      params.starCount = 1000; // Reduced from 1500
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2));
      break;
    case "high":
      params.circleCount = 80; // Reduced from 100
      params.circleSegments = 64; // Reduced from 128
      params.tubeSegments = 6; // Reduced from 8
      params.particlesEnabled = true;
      params.particleCount = 500; // Reduced from 1000
      params.useBloom = true;
      params.starCount = 1500; // Reduced from 2000
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      break;
  }

  // Update UI
  pane.refresh();

  // Rebuild tunnel with new settings
  createTunnel();
}

// Setup Tweakpane
const pane = new Pane({
  container: document.getElementById("tweakpane-container")
});

// Automatically set quality preset based on device
if (isLowEndDevice) {
  applyQualityPreset("low");
} else if (isMobile) {
  applyQualityPreset("medium");
} else {
  applyQualityPreset("high");
}

// Function to save current values
function saveCurrentValues() {
  const currentValues = {};
  for (const key in params) {
    currentValues[key] = params[key];
  }
  console.log('Current Values:', currentValues);
  return currentValues;
}

// Add tabs
const tabs = pane.addTab({
  pages: [
    { title: "Presets" },
    { title: "Structure" },
    { title: "Appearance" },
    { title: "Effects" },
    { title: "Stars" },
    { title: "Movement" },
    { title: "Performance" },
    { title: "Title" },
    { title: "Narration" }
  ]
});

// Presets tab
const presetsTab = tabs.pages[0];

// Add save button at the top of presets tab
presetsTab.addButton({
  title: 'Save Current Values',
  label: 'SAVE CURRENT SETTINGS',
}).on('click', () => {
  // Get all current values
  const currentSettings = {
    // Structure
    tunnelDepth: params.tunnelDepth,
    circleCount: params.circleCount,
    tunnelRadius: params.tunnelRadius,
    tubeThickness: params.tubeThickness,
    circleSegments: params.circleSegments,
    tubeSegments: params.tubeSegments,
    pathAmplitude: params.pathAmplitude,

    // Appearance
    colorA: params.colorA,
    colorB: params.colorB,
    colorC: params.colorC,
    colorD: params.colorD,
    emission: params.emission,
    metalness: params.metalness,
    roughness: params.roughness,
    fogDensity: params.fogDensity,

    // Effects
    pulseSpeed: params.pulseSpeed,
    pulseIntensity: params.pulseIntensity,
    rotationSpeed: params.rotationSpeed,
    particlesEnabled: params.particlesEnabled,
    particleCount: params.particleCount,
    particleSize: params.particleSize,
    particleSpeed: params.particleSpeed,

    // Stars
    starsEnabled: params.starsEnabled,
    starCount: params.starCount,
    starSize: params.starSize,

    // Movement
    autoMovement: params.autoMovement,
    manualPosition: params.manualPosition,
    scrollSpeed: params.scrollSpeed,
    fadeStart: params.fadeStart,
    fadeIntensity: params.fadeIntensity,

    // Performance
    qualityPreset: params.qualityPreset,
    useBloom: params.useBloom,

    // Title settings
    titleShowThreshold: params.titleShowThreshold,
    titleHideThreshold: params.titleHideThreshold,

    // Narration settings
    narrationPoints: params.narrationPoints,
    narrationShowThreshold: params.narrationShowThreshold,
    narrationHideThreshold: params.narrationHideThreshold
  };

  // Log the current settings
  console.log('Current Settings:', JSON.stringify(currentSettings, null, 2));
  
  // Update the default parameters
  Object.assign(params, currentSettings);
  
  // Rebuild tunnel with new values
  createTunnel();
  
  // Show confirmation
  alert('Current settings have been saved as defaults!');
});

presetsTab
  .addBinding(params, "colorPreset", {
    options: {
      Default: "default",
      "Dark Abyss": "dark-abyss",
      "Neon Dreams": "neon-dreams",
      "Golden Hour": "golden-hour",
      "Deep Ocean": "deep-ocean",
      "Aurora Borealis": "aurora-borealis"
    }
  })
  .on("change", (ev) => {
    applyColorPreset(ev.value);
  });

// Structure tab
const structureTab = tabs.pages[1];
structureTab
  .addBinding(params, "circleCount", { min: 10, max: 120, step: 5 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "tunnelRadius", { min: 1, max: 10, step: 0.5 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "tubeThickness", { min: 0.02, max: 0.5, step: 0.01 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "circleSegments", { min: 12, max: 128, step: 4 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "tunnelDepth", { min: 50, max: 200, step: 10 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "pathAmplitude", { min: 0, max: 2, step: 0.1 })
  .on("change", () => createTunnel());

// Appearance tab
const appearanceTab = tabs.pages[2];
const colorInputs = [
  appearanceTab
    .addBinding(params, "colorA", { label: "Color 1 (Start)" })
    .on("change", () => createTunnel()),
  appearanceTab
    .addBinding(params, "colorB", { label: "Color 2 (25%)" })
    .on("change", () => createTunnel()),
  appearanceTab
    .addBinding(params, "colorC", { label: "Color 3 (50%)" })
    .on("change", () => createTunnel()),
  appearanceTab
    .addBinding(params, "colorD", { label: "Color 4 (75%)" })
    .on("change", () => createTunnel())
];

appearanceTab
  .addBinding(params, "emission", { min: 0, max: 1, step: 0.05 })
  .on("change", () => createTunnel());
appearanceTab
  .addBinding(params, "metalness", { min: 0, max: 1, step: 0.05 })
  .on("change", () => createTunnel());
appearanceTab
  .addBinding(params, "roughness", { min: 0, max: 1, step: 0.05 })
  .on("change", () => createTunnel());
appearanceTab
  .addBinding(params, "fogDensity", { min: 0, max: 0.1, step: 0.005 })
  .on("change", () => {
    scene.fog.density = params.fogDensity;
  });

// Effects tab
const effectsTab = tabs.pages[3];
effectsTab.addBinding(params, "pulseIntensity", { min: 0, max: 1, step: 0.05 });
effectsTab.addBinding(params, "pulseSpeed", { min: 0.1, max: 5, step: 0.1 });
effectsTab.addBinding(params, "rotationSpeed", {
  min: 0,
  max: 0.05,
  step: 0.001
});
effectsTab
  .addBinding(params, "particlesEnabled")
  .on("change", () => createTunnel());
effectsTab
  .addBinding(params, "particleCount", { min: 100, max: 1000, step: 50 })
  .on("change", () => createTunnel());
effectsTab
  .addBinding(params, "particleSize", { min: 0.01, max: 0.2, step: 0.01 })
  .on("change", () => createTunnel());
effectsTab.addBinding(params, "particleSpeed", {
  min: 0.1,
  max: 1.0,
  step: 0.1
});

// Stars tab
const starsTab = tabs.pages[4];
starsTab
  .addBinding(params, "starsEnabled")
  .on("change", () => createStarField());
starsTab
  .addBinding(params, "starCount", { min: 500, max: 3000, step: 100 })
  .on("change", () => createStarField());
starsTab
  .addBinding(params, "starSize", { min: 0.01, max: 0.2, step: 0.01 })
  .on("change", () => createStarField());

// Movement tab
const movementTab = tabs.pages[5];
movementTab.addBinding(params, "autoMovement").on("change", (ev) => {
  // Show/hide manual position slider based on auto movement setting
  manualPositionInput.hidden = ev.value;
});
const manualPositionInput = movementTab.addBinding(params, "manualPosition", {
  min: 0,
  max: 0.99,
  step: 0.01
});
// Initially hide manual position if auto movement is enabled
manualPositionInput.hidden = params.autoMovement;

movementTab.addBinding(params, "scrollSpeed", {
  min: 0.1,
  max: 2.0,
  step: 0.1
});
movementTab.addBinding(params, "fadeStart", {
  min: 0.5,
  max: 0.95,
  step: 0.05
});
movementTab.addBinding(params, "fadeIntensity", { min: 1, max: 5, step: 0.5 });

// Performance tab
const performanceTab = tabs.pages[6];
performanceTab
  .addBinding(params, "qualityPreset", {
    options: {
      Low: "low",
      Medium: "medium",
      High: "high"
    }
  })
  .on("change", (ev) => {
    applyQualityPreset(ev.value);
  });

performanceTab.addBinding(params, "useBloom").on("change", () => {
  // No need to rebuild tunnel, just toggle bloom effect
});

// Title tab - for controlling title settings
const titleTab = tabs.pages[7];
titleTab.addBinding(params, "titleShowThreshold", {
  min: 0.5,
  max: 0.99,
  step: 0.01,
  label: "Show at"
});
titleTab
  .addBinding(params, "titleHideThreshold", {
    min: 0.5,
    max: 0.99,
    step: 0.01,
    label: "Hide at"
  })
  .on("change", () => {
    // Ensure hide threshold is less than show threshold
    if (params.titleHideThreshold >= params.titleShowThreshold) {
      params.titleHideThreshold = params.titleShowThreshold - 0.02;
      pane.refresh();
    }
  });

// Narration tab
const narrationTab = tabs.pages[8];
narrationTab.addBinding(params, "narrationShowThreshold", {
  min: 0.01,
  max: 0.99,
  step: 0.01,
  label: "Show at"
});
narrationTab
  .addBinding(params, "narrationHideThreshold", {
    min: 0.01,
    max: 0.99,
    step: 0.01,
    label: "Hide at"
  })
  .on("change", () => {
    // Ensure hide threshold is less than show threshold
    if (params.narrationHideThreshold >= params.narrationShowThreshold) {
      params.narrationHideThreshold = params.narrationShowThreshold - 0.02;
      pane.refresh();
    }
  });

// Restore updateNarrationImageForMobile for narration image swapping
function updateNarrationImageForMobile() {
  const img = document.getElementById('narration-img-main');
  if (!img) return;
  if (window.innerWidth <= 600) {
    img.src = 'svg/walloffame-logomobile.png';
  } else {
    img.src = 'svg/Text 1.png';
  }
}
window.addEventListener('resize', updateNarrationImageForMobile);
document.addEventListener('DOMContentLoaded', () => {
  updateNarrationImageForMobile();
  updateNarrationByIndex(0, 0);
});

function createTunnel() {
  // Remove previous tunnel
  scene.remove(tunnelGroup);
  tunnelGroup = new THREE.Group();
  scene.add(tunnelGroup);

  // Update path
  tunnelPath = createPath();

  // Skip particle creation
  // createParticles();

  // Create star field (background only, no warp)
  createStarField();

  // Create tunnel end particles
  createTunnelEndParticles();

  // Restore tunnel ring creation
  const colorA = new THREE.Color(params.colorA);
  const colorB = new THREE.Color(params.colorB);
  const colorC = new THREE.Color(params.colorC);
  const colorD = new THREE.Color(params.colorD);
  const geometry = getTorusGeometry(
    params.tunnelRadius,
    params.tubeThickness,
    params.tubeSegments,
    params.circleSegments
  );
  for (let i = 0; i < params.circleCount; i++) {
    const t = i / (params.circleCount - 1);
    const pathPoint = tunnelPath.getPointAt(t);
    let color;
    if (t < 0.25) {
      color = new THREE.Color().lerpColors(colorA, colorB, t * 4);
    } else if (t < 0.5) {
      color = new THREE.Color().lerpColors(colorB, colorC, (t - 0.25) * 4);
    } else if (t < 0.75) {
      color = new THREE.Color().lerpColors(colorC, colorD, (t - 0.5) * 4);
    } else {
      color = colorD.clone().multiplyScalar(1 - (t - 0.75) * 0.5);
    }
    const material = new THREE.MeshStandardMaterial({
      color: color,
      emissive: color.clone().multiplyScalar(params.emission),
      metalness: params.metalness,
      roughness: params.roughness,
      transparent: true
    });
    const torus = new THREE.Mesh(geometry, material);
    const tangent = tunnelPath.getTangentAt(t);
    torus.position.copy(pathPoint);
    if (Math.abs(tangent.y) < 0.99) {
      torus.lookAt(
        pathPoint.x + tangent.x,
        pathPoint.y + tangent.y,
        pathPoint.z + tangent.z
      );
    }
    torus.userData = {
      initialPositionZ: torus.position.z,
      index: i,
      t: t
    };
    tunnelGroup.add(torus);
  }

  console.log('Tunnel rings:', tunnelGroup.children.length);
}

// Ensure the tunnel is created on load
createTunnel();

  </script>
</body>
</html>


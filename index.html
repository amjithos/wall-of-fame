<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WALL OF FAME | SSALE</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=Staatliches&display=swap" rel="stylesheet"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <style>
    /* Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Base */
    body {
      background-color: #000;
      color: white;
      font-family: "Inter", sans-serif;
      height: 10000px;
      overflow-x: hidden;
      letter-spacing: -0.02em;
    }

    /* Layout */
    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .tweakpane-container {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: none;
    }

    /* Title Section */
    .title-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 800px;
      text-align: center;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: opacity 1.2s ease, visibility 0s 1.2s;
    }

    .title-container.visible {
      opacity: 1;
      visibility: visible;
      transition: opacity 1.2s ease, visibility 0s;
    }

    /* Typography */
    h1 {
      font-family: "Staatliches", sans-serif;
      font-size: 8rem;
      line-height: 0.9;
      letter-spacing: -0.02em;
      text-transform: uppercase;
      margin-bottom: 1rem;
    }

    h2 {
      font-family: "Staatliches", sans-serif;
      font-size: 2rem;
      line-height: 1;
      letter-spacing: 0.05em;
      margin: 0 auto 3rem;
      max-width: 600px;
    }

    .quote {
      font-family: "Inter", sans-serif;
      font-size: 1.2rem;
      font-weight: 400;
      line-height: 1.5;
      max-width: 700px;
      margin: 2rem auto 0;
      letter-spacing: -0.03em;
    }

    /* Responsive */
    @media (max-width: 768px) {
      h1 {
        font-size: 3.5rem;
        margin-bottom: 1.5rem;
      }

      h2 {
        font-size: 1.5rem;
        margin-bottom: 2rem;
      }

      .quote {
        font-size: 1rem;
        line-height: 1.4;
      }
    }

    .cta-btn {
      display: block;
      margin: 2rem auto 0 auto;
      padding: 1rem 2.5rem;
      font-size: 1.3rem;
      max-width: 500px;
      font-family: "Staatliches", sans-serif;
      background: #ff3030;
      color: #fff;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
      box-shadow: 0 4px 24px rgba(0,0,0,0.12);
    }
    .cta-btn:hover {
      background: #ff6000;
      transform: scale(1.05);
    }
    .logo-style {
      max-width: 320px;
      width: 60vw;
      height: auto;
      margin-bottom: 2rem;
    }
    @media (max-width: 600px) {
      .logo-style {
        width: 90vw;
        max-width: 200px;
        margin-bottom: 1.2rem;
      }
      .cta-btn {
        font-size: 1rem;
        padding: 0.8rem 1.8rem;
      }
      .subtitle {
        font-size: 1.1rem;
      }
    }

    .header .nav-section a {
      text-decoration: none !important;
      background: none !important;
      color: inherit !important;
      font-family: inherit !important;
      font-size: inherit !important;
      font-weight: inherit !important;
      letter-spacing: inherit !important;
      box-shadow: none !important;
      transition: none !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .header .nav-section a::after {
      display: none !important;
      content: none !important;
    }

    /* Narration System */
    .narration-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 800px;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .narration-container.visible {
      opacity: 1;
      visibility: visible;
    }

    .narration-text {
      text-align: center;
      margin-bottom: 2rem;
      font-weight: 300;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
      width: 100%;
    }

    .narration-text h1 {
      font-family: "Staatliches", sans-serif;
      font-size: clamp(2.5rem, 8vw, 4.5rem);
      line-height: 1.1;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .narration-text h3 {
      font-family: "Staatliches", sans-serif;
      font-size: clamp(1.2rem, 4vw, 2rem);
      line-height: 1.2;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .narration-text p {
      font-size: clamp(1rem, 3vw, 1.4rem);
      line-height: 1.5;
      margin: 0;
      font-weight: 300;
    }

    /* Progress bar styles */
    .progress-container {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      z-index: 1000;
      backdrop-filter: blur(4px);
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(255, 48, 48, 0.8),
        rgba(255, 96, 0, 0.8)
      );
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 15px rgba(255, 48, 48, 0.4);
      position: relative;
    }

    .progress-percentage {
      position: absolute;
      right: 0;
      top: -25px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: "Inter", sans-serif;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      white-space: nowrap;
    }

    .progress-bar:hover .progress-percentage {
      opacity: 1;
    }

    @media (max-width: 768px) {
      .progress-percentage {
        font-size: 10px;
        top: -20px;
      }
    }

    @media (max-width: 480px) {
      .narration-container {
        padding: 0.5rem;
      }
      
      .narration-text {
        margin-bottom: 1rem;
      }
    }

    .lottie-swipe-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      height: 400px;
      z-index: 1100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .lottie-swipe-container.visible {
      opacity: 1;
    }
    @media (max-width: 900px) {
      .lottie-swipe-container {
        width: 250px;
        height: 250px;
      }
    }
    @media (max-width: 600px) {
      .lottie-swipe-container {
        width: 140px;
        height: 140px;
      }
    }

    body.bg-end {
      background: url('https://images.unsplash.com/photo-1624269636254-c4dc6c1d0e44?q=80&w=2684&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D') center center / contain no-repeat !important;
      background-color: #000 !important;
      opacity: 1 !important;
      z-index: 99999 !important;
    }

    #container:not(.bg-end) {
      background: none;
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="tunnel"></canvas>
  </div>

  <!-- Lottie Swipe Animation (just above progress bar) -->
  <div class="lottie-swipe-container" id="lottie-swipe-container"></div>

  <!-- Progress bar container -->
  <div class="progress-container">
    <div class="progress-bar" id="progress-bar">
      <span class="progress-percentage" id="progress-percentage">0%</span>
    </div>
  </div>

  <!-- Narration container -->
  <div class="narration-container" id="narration-container">
    <div class="narration-text" id="narration-text"></div>
  </div>

  <!-- Title and subtitle container -->
  <div class="title-container" id="title-container">
    <img src="./pages/SSALE LOGO.svg" alt="SSALE Logo" class="logo-style" style="display: block; margin: 0 auto 2rem; max-width: 500px; width: 60vw; height: auto;" />
    <h2 class="subtitle">LIVE NOW!</h2>
    <a href="./pages/wall.html" class="cta-btn">EXPLORE NOW</a>
  </div>

  <!-- Tweakpane container -->
  <div class="tweakpane-container" id="tweakpane-container"></div>

  <!-- GSAP and ScrollTrigger -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

  <!-- Main Script -->
  <script type="module">
    // Import modules
import * as THREE from "https://esm.sh/three@0.175.0";
import { Pane } from "https://cdn.skypack.dev/tweakpane@4.0.4";
import Stats from "https://esm.sh/stats.js@0.17.0";
import { EffectComposer } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/UnrealBloomPass.js";

// Register ScrollTrigger
gsap.registerPlugin(ScrollTrigger);

// Detect device capabilities for performance optimization
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
);
const isLowEndDevice =
  isMobile ||
  (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4);

// Color presets
const colorPresets = {
  default: {
    colorA: "#ff3030", // Start of tunnel
    colorB: "#ff6000", // After first quarter
    colorC: "#ffcf00", // After second quarter
    colorD: "#ffec7f" // End of tunnel
  },
  "dark-abyss": {
    colorA: "#0a0a2a", // Deep dark blue
    colorB: "#1a1a4a", // Dark blue
    colorC: "#3a1a6a", // Dark purple
    colorD: "#0a0a1a" // Almost black
  },
  "neon-dreams": {
    colorA: "#ff00ff", // Neon pink
    colorB: "#00ff99", // Neon green
    colorC: "#ff3399", // Bright pink
    colorD: "#9900ff" // Neon purple
  },
  "golden-hour": {
    colorA: "#ff7700", // Bright orange
    colorB: "#ff3300", // Reddish orange
    colorC: "#ffaa00", // Golden yellow
    colorD: "#ff0000" // Deep red
  },
  "deep-ocean": {
    colorA: "#006699", // Deep blue
    colorB: "#00aacc", // Turquoise
    colorC: "#006666", // Teal
    colorD: "#003366" // Navy blue
  },
  "aurora-borealis": {
    colorA: "#00cc99", // Green
    colorB: "#6600cc", // Purple
    colorC: "#00ffcc", // Bright green
    colorD: "#3300ff" // Deep blue
  }
};

// Parameters
const params = {
  // Structure
  tunnelDepth: 50,
  circleCount: 100,
  tunnelRadius: 3,
  tubeThickness: 0.5,
  circleSegments: 128,
  tubeSegments: 8,
  pathAmplitude: 0.5,

  // Appearance
  colorA: "#ff3030",
  colorB: "#ff6000",
  colorC: "#ffcf00",
  colorD: "#ffec7f",
  emission: 0.1,
  metalness: 0.7,
  roughness: 0.4,
  fogDensity: 0.065,

  // Effects
  pulseSpeed: 4.7,
  pulseIntensity: 0.8,
  rotationSpeed: 0.011,
  particlesEnabled: true,
  particleCount: 1000,
  particleSize: 0.04,
  particleSpeed: 0.5,

  // Stars
  starsEnabled: true,
  starCount: 2000,
  starSize: 0.05,

  // Movement
  autoMovement: true,
  manualPosition: 0,
  scrollSpeed: 1,
  fadeStart: 0.85,
  fadeIntensity: 3,

  // Performance
  qualityPreset: "high",
  useBloom: true,

  // Presets
  colorPreset: "default",

  // Title settings
  titleShowThreshold: 0.95,
  titleHideThreshold: 0.93,

  // Narration settings
  narrationPoints: [
    { 
      progress: 0.01, 
      text: '<h1>Welcome to</h1><h1>Shoppers Stop</h1><h1>Wall of Fame</h1>'
    },
    { 
      progress: 0.26, 
      text: '<h1>Discover the season\'s most-loved brands.</h1>'
    },
    { 
      progress: 0.52, 
      text: '<h1>With deals you can\'t miss.</h1>'
    },
    { 
      progress: 0.75, 
      text: '<h1>Across every category you love.</h1>'
    }
  ],
  narrationShowThreshold: 0.01,
  narrationHideThreshold: 0.95,

  // Swipe instruction settings
  swipeShowDuration: 5000, // Show for 5 seconds total
  swipeFadeInDuration: 1000, // Fade in over 1 second
  swipeFadeOutDuration: 1000, // Fade out over 1 second
  swipePulseDuration: 2000, // Each pulse cycle duration
};

// Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, params.fogDensity);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("tunnel"),
  antialias: !isLowEndDevice,
  powerPreference: "high-performance"
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(isLowEndDevice ? 1 : window.devicePixelRatio || 1);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;

// Setup post-processing with bloom
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

// Add bloom effect
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.5, // Bloom strength
  0.75, // Bloom radius
  0.2 // Bloom threshold
);
composer.addPass(bloomPass);

// Stats
const stats = new Stats();
stats.showPanel(0);
document.body.appendChild(stats.dom);
stats.dom.style.display = 'none';

// Add lights
const ambientLight = new THREE.AmbientLight(0x404040, 1);
scene.add(ambientLight);

const light1 = new THREE.PointLight(0xff3030, 2, 50);
light1.position.set(0, 0, 10);
scene.add(light1);

const light2 = new THREE.PointLight(0xff6000, 2, 50);
light2.position.set(0, 0, -20);
scene.add(light2);

// Object pool for geometry reuse
const geometryPool = {
  torus: {}
};

// Get or create torus geometry from pool
function getTorusGeometry(radius, tubeThickness, tubeSegments, circleSegments) {
  const key = `${radius}-${tubeThickness}-${tubeSegments}-${circleSegments}`;
  if (!geometryPool.torus[key]) {
    geometryPool.torus[key] = new THREE.TorusGeometry(
      radius,
      tubeThickness,
      tubeSegments,
      circleSegments
    );
  }
  return geometryPool.torus[key];
}

// Create tunnel path
function createPath() {
  const path = [];
  const segments = 100;

  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const z = -t * params.tunnelDepth;

    // Sine wave path for more interest
    const x = Math.sin(t * 10) * params.pathAmplitude;
    const y = Math.cos(t * 8) * params.pathAmplitude;

    path.push(new THREE.Vector3(x, y, z));
  }

  return new THREE.CatmullRomCurve3(path);
}

let tunnelPath = createPath();

// Group for all circles
let tunnelGroup = new THREE.Group();
scene.add(tunnelGroup);

// Particle system for floating dust
let particles;
let particleTexture;

// Star field
let starField;
let starTexture;

// Create a circular particle texture (only once)
function createParticleTexture() {
  if (particleTexture) return particleTexture;

  const canvas = document.createElement("canvas");
  canvas.width = 32;
  canvas.height = 32;

  const context = canvas.getContext("2d");
  const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
  gradient.addColorStop(0, "rgba(255,255,255,1)");
  gradient.addColorStop(1, "rgba(255,255,255,0)");

  context.fillStyle = gradient;
  context.fillRect(0, 0, 32, 32);

  particleTexture = new THREE.Texture(canvas);
  particleTexture.needsUpdate = true;
  return particleTexture;
}

// Create a star texture (only once)
function createStarTexture() {
  if (starTexture) return starTexture;

  const canvas = document.createElement("canvas");
  canvas.width = 32;
  canvas.height = 32;

  const context = canvas.getContext("2d");
  const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
  gradient.addColorStop(0, "rgba(255,255,255,1)");
  gradient.addColorStop(0.4, "rgba(200,220,255,0.8)");
  gradient.addColorStop(1, "rgba(200,220,255,0)");

  context.fillStyle = gradient;
  context.fillRect(0, 0, 32, 32);

  starTexture = new THREE.Texture(canvas);
  starTexture.needsUpdate = true;
  return starTexture;
}

// Create star field (background stars, no warp effect)
function createStarField() {
  if (starField) scene.remove(starField);

  if (!params.starsEnabled) return;

  const starGeo = new THREE.BufferGeometry();
  const starPositions = [];
  const starSizes = [];
  const starColors = [];

  // Create stars in a spherical distribution around the tunnel
  const sphereRadius = 100; // Large radius to place stars far away

  for (let i = 0; i < params.starCount; i++) {
    // Random spherical coordinates
    const theta = Math.random() * Math.PI * 2; // Azimuthal angle
    const phi = Math.acos(2 * Math.random() - 1); // Polar angle

    // Convert to Cartesian coordinates
    const x = sphereRadius * Math.sin(phi) * Math.cos(theta);
    const y = sphereRadius * Math.sin(phi) * Math.sin(theta);
    const z = sphereRadius * Math.cos(phi);

    starPositions.push(x, y, z);

    // Random size variation
    const size = params.starSize * (0.5 + Math.random() * 0.5);
    starSizes.push(size);

    // Slightly varied white/blue colors for stars
    const r = 0.8 + Math.random() * 0.2;
    const g = 0.8 + Math.random() * 0.2;
    const b = 0.9 + Math.random() * 0.1;
    starColors.push(r, g, b);
  }

  // Set attributes
  starGeo.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(starPositions, 3)
  );
  starGeo.setAttribute(
    "color",
    new THREE.Float32BufferAttribute(starColors, 3)
  );
  starGeo.setAttribute("size", new THREE.Float32BufferAttribute(starSizes, 1));

  // Create material with custom shader for better star rendering
  const starMaterial = new THREE.PointsMaterial({
    size: params.starSize,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
    map: createStarTexture(),
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  starField = new THREE.Points(starGeo, starMaterial);
  scene.add(starField);
}

// Create particles
function createParticles() {
  if (particles) scene.remove(particles);

  if (!params.particlesEnabled) return;

  const particleGeo = new THREE.BufferGeometry();
  const particlePositions = [];
  const particleColors = [];
  const particleVelocities = [];

  const colorA = new THREE.Color(params.colorA);
  const colorB = new THREE.Color(params.colorB);
  const colorC = new THREE.Color(params.colorC);
  const colorD = new THREE.Color(params.colorD);

  for (let i = 0; i < params.particleCount; i++) {
    // Random position within tunnel volume
    const t = Math.random();
    const ringRadius = params.tunnelRadius * (0.5 + Math.random() * 0.5); // Vary radius
    const angle = Math.random() * Math.PI * 2;

    // Calculate position on path
    const pathPoint = tunnelPath.getPointAt(t);

    // Random position within tube radius
    const x = pathPoint.x + Math.cos(angle) * ringRadius;
    const y = pathPoint.y + Math.sin(angle) * ringRadius;
    const z = pathPoint.z;

    particlePositions.push(x, y, z);

    // Random velocities for movement
    particleVelocities.push(
      (Math.random() - 0.5) * 0.01,
      (Math.random() - 0.5) * 0.01,
      (Math.random() - 0.5) * 0.01
    );

    // Blend colors based on position in tunnel
    let color;
    if (t < 0.25) {
      color = new THREE.Color().lerpColors(colorA, colorB, t * 4);
    } else if (t < 0.5) {
      color = new THREE.Color().lerpColors(colorB, colorC, (t - 0.25) * 4);
    } else if (t < 0.75) {
      color = new THREE.Color().lerpColors(colorC, colorD, (t - 0.5) * 4);
    } else {
      color = colorD.clone();
    }

    particleColors.push(color.r, color.g, color.b);
  }

  // Set attributes
  particleGeo.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(particlePositions, 3)
  );
  particleGeo.setAttribute(
    "color",
    new THREE.Float32BufferAttribute(particleColors, 3)
  );

  // Create material
  const particleMaterial = new THREE.PointsMaterial({
    size: params.particleSize,
    vertexColors: true,
    transparent: true,
    opacity: 0.6,
    map: createParticleTexture(),
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  particles = new THREE.Points(particleGeo, particleMaterial);
  particles.userData = {
    initialPositions: [...particlePositions], // Clone the initial positions
    velocities: particleVelocities
  };

  scene.add(particles);
}

// At the top-level, after other top-level variables:
let tunnelEndPlane = null;

// In createTunnel, remove 'let' from 'let tunnelEndPlane;' and clean up old plane if it exists:
function createTunnel() {
  // Remove previous tunnel
  scene.remove(tunnelGroup);
  tunnelGroup = new THREE.Group();
  scene.add(tunnelGroup);

  // Update path
  tunnelPath = createPath();

  // Create particle system
  createParticles();

  // Create star field (background only, no warp)
  createStarField();

  // Create materials
  const colorA = new THREE.Color(params.colorA);
  const colorB = new THREE.Color(params.colorB);
  const colorC = new THREE.Color(params.colorC);
  const colorD = new THREE.Color(params.colorD);

  // Get shared geometry from pool
  const geometry = getTorusGeometry(
    params.tunnelRadius,
    params.tubeThickness,
    params.tubeSegments,
    params.circleSegments
  );

  // Create circles along the path
  for (let i = 0; i < params.circleCount; i++) {
    const t = i / (params.circleCount - 1);
    const pathPoint = tunnelPath.getPointAt(t);

    // Calculate color for this ring using 4-color gradient
    let color;
    if (t < 0.25) {
      // First quarter: colorA to colorB
      color = new THREE.Color().lerpColors(colorA, colorB, t * 4);
    } else if (t < 0.5) {
      // Second quarter: colorB to colorC
      color = new THREE.Color().lerpColors(colorB, colorC, (t - 0.25) * 4);
    } else if (t < 0.75) {
      // Third quarter: colorC to colorD
      color = new THREE.Color().lerpColors(colorC, colorD, (t - 0.5) * 4);
    } else {
      // Last quarter: colorD with darkening
      color = colorD.clone().multiplyScalar(1 - (t - 0.75) * 0.5);
    }

    const material = new THREE.MeshStandardMaterial({
      color: color,
      emissive: color.clone().multiplyScalar(params.emission),
      metalness: params.metalness,
      roughness: params.roughness,
      transparent: true
    });

    // Create a torus (ring tube) - reuse geometry
    const torus = new THREE.Mesh(geometry, material);

    // Get tangent direction for orientation
    const tangent = tunnelPath.getTangentAt(t);

    // Position and orient the ring
    torus.position.copy(pathPoint);

    // Align ring with the tangent direction
    if (Math.abs(tangent.y) < 0.99) {
      torus.lookAt(
        pathPoint.x + tangent.x,
        pathPoint.y + tangent.y,
        pathPoint.z + tangent.z
      );
    }

    // Store some data for animations
    torus.userData = {
      initialPositionZ: torus.position.z,
      index: i,
      t: t
    };

    tunnelGroup.add(torus);
  }

  // Update fog
  scene.fog.density = params.fogDensity;
}

// Initial creation
createTunnel();

// Animation and scroll handling
let scrollProgress = 0;
let lastFrameTime = 0;
let deltaTime = 0;

// Get title container element
const titleContainer = document.getElementById("title-container");
let titleVisible = false;

// Get narration elements
const narrationContainer = document.getElementById("narration-container");
const narrationText = document.getElementById("narration-text");
const progressBar = document.getElementById("progress-bar");

// Add this after DOMContentLoaded or after your other top-level variables:
const lottieSwipeContainer = document.getElementById('lottie-swipe-container');
let lottieSwipeAnim = null;
let lottieLoaded = false;
let lottieSwipeTimeout = null;
let lottieSwipeShown = false;

function showLottieSwipe(force = false) {
  if (!lottieLoaded) {
    lottieSwipeAnim = lottie.loadAnimation({
      container: lottieSwipeContainer,
      renderer: 'svg',
      loop: true,
      autoplay: true,
      path: './animations/swipe-up.json' // Your Lottie file path
    });
    lottieLoaded = true;
  }
  lottieSwipeContainer.classList.add('visible');
  lottieSwipeShown = true;
}

function hideLottieSwipe() {
  lottieSwipeContainer.classList.remove('visible');
  if (lottieSwipeAnim) {
    lottieSwipeAnim.destroy();
    lottieSwipeContainer.innerHTML = '';
    lottieLoaded = false;
  }
  lottieSwipeShown = false;
}

// Show Lottie immediately on load
showLottieSwipe();

// Hide after 2 seconds or on scroll
lottieSwipeTimeout = setTimeout(() => {
  hideLottieSwipe();
}, 2000);

window.addEventListener('scroll', () => {
  if (lottieSwipeShown) {
    hideLottieSwipe();
    clearTimeout(lottieSwipeTimeout);
  }
}, { once: true });

// Function to update narration
function updateNarration(progress) {
  // Update progress bar
  const percentage = Math.round(progress * 100);
  const progressBar = document.getElementById('progress-bar');
  progressBar.style.width = `${percentage}%`;
  
  // Update percentage text
  const percentageElement = document.getElementById('progress-percentage');
  if (percentageElement) {
    percentageElement.textContent = `${percentage}%`;
  }

  // Find current narration point
  const currentPoint = params.narrationPoints.reduce((prev, curr) => {
    return (curr.progress <= progress && curr.progress > prev.progress) ? curr : prev;
  }, params.narrationPoints[0]);

  // Update narration text
  narrationText.innerHTML = currentPoint.text;

  // Show/hide narration container based on progress
  if (progress >= params.narrationShowThreshold && progress <= params.narrationHideThreshold) {
    narrationContainer.classList.add("visible");
  } else {
    narrationContainer.classList.remove("visible");
  }
}

// Set up ScrollTrigger
ScrollTrigger.create({
  trigger: "body",
  start: "top top",
  end: "bottom bottom",
  onUpdate: (self) => {
    scrollProgress = self.progress;

    // Handle title visibility
    if (scrollProgress >= params.titleShowThreshold && !titleVisible) {
      titleContainer.classList.add("visible");
      titleVisible = true;
    } else if (scrollProgress < params.titleHideThreshold && titleVisible) {
      titleContainer.classList.remove("visible");
      titleVisible = false;
    }

    // Update narration
    updateNarration(scrollProgress);

    if (self.progress > 0.01) {
      document.querySelector(".scroll-indicator")?.classList.add("hidden");
    }
  }
});

// Animation loop
let time = 0;
let animationFrameId;

function animate(currentTime = 0) {
  stats.begin();

  // Calculate delta time for smooth animations regardless of frame rate
  deltaTime = Math.min(0.05, (currentTime - lastFrameTime) / 1000); // Cap at 0.05 (20fps minimum)
  lastFrameTime = currentTime;

  time += deltaTime;

  // Calculate camera position based on scroll or manual position
  let pathProgress;
  if (params.autoMovement) {
    pathProgress = Math.min(scrollProgress * params.scrollSpeed, 0.99);
  } else {
    pathProgress = Math.min(Math.max(params.manualPosition, 0), 0.99);
  }

  const position = tunnelPath.getPointAt(pathProgress);

  // Set camera position
  camera.position.copy(position);

  // Look ahead
  const lookAtPosition = tunnelPath.getPointAt(
    Math.min(pathProgress + 0.01, 0.99)
  );
  camera.lookAt(lookAtPosition);

  // Move lights with camera
  light1.position.copy(camera.position);
  light1.position.z += 3;

  // Animate rings (subtle pulsing and rotation)
  if (params.pulseIntensity > 0 || params.rotationSpeed > 0) {
    // Only process visible rings for optimization
    tunnelGroup.children.forEach((ring, i) => {
      // Skip rings that are too far from camera
      const distanceToCamera = camera.position.distanceTo(ring.position);
      if (distanceToCamera > params.tunnelDepth * 0.5) return;

      if (params.pulseIntensity > 0) {
        // Calculate pulse (based on time and position)
        const pulse =
          Math.sin(time * params.pulseSpeed + ring.userData.index * 0.2) *
          params.pulseIntensity;

        // Apply pulse to emission intensity
        const baseEmission = params.emission;
        const emissionColor = ring.material.color
          .clone()
          .multiplyScalar(baseEmission * (1 + pulse));
        ring.material.emissive.copy(emissionColor);
      }

      // Add subtle rotation to each ring
      if (params.rotationSpeed > 0) {
        ring.rotation.z +=
          params.rotationSpeed *
          deltaTime *
          60 *
          (1 + Math.sin(ring.userData.index * 0.1) * 0.5);
      }
    });
  }

  // Animate particles
  if (particles && params.particlesEnabled) {
    const positions = particles.geometry.attributes.position.array;
    const initialPositions = particles.userData.initialPositions;
    const velocities = particles.userData.velocities;

    // Update particle positions - batch process for performance
    for (let i = 0; i < params.particleCount; i++) {
      const idx = i * 3;
      const vIdx = i * 3;

      // Move particles slowly
      positions[idx] +=
        velocities[vIdx] * params.particleSpeed * deltaTime * 60;
      positions[idx + 1] +=
        velocities[vIdx + 1] * params.particleSpeed * deltaTime * 60;
      positions[idx + 2] +=
        velocities[vIdx + 2] * params.particleSpeed * deltaTime * 60;

      // Reset particles that get too far from their original position
      const dx = positions[idx] - initialPositions[idx];
      const dy = positions[idx + 1] - initialPositions[idx + 1];
      const dz = positions[idx + 2] - initialPositions[idx + 2];
      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

      if (distance > 1.0) {
        // Reset with new velocity
        positions[idx] = initialPositions[idx];
        positions[idx + 1] = initialPositions[idx + 1];
        positions[idx + 2] = initialPositions[idx + 2];
        velocities[vIdx] = (Math.random() - 0.5) * 0.01;
        velocities[vIdx + 1] = (Math.random() - 0.5) * 0.01;
        velocities[vIdx + 2] = (Math.random() - 0.5) * 0.01;
      }
    }

    particles.geometry.attributes.position.needsUpdate = true;
  }

  // Handle fade to black at end
  if (pathProgress > params.fadeStart) {
    document.body.classList.add('bg-end');
    if (pathProgress > 0.99) {
      document.getElementById('container').style.opacity = 0;
      document.getElementById('container').style.display = 'none';
      document.querySelectorAll('canvas').forEach(c => c.style.display = 'none');
    } else {
      document.getElementById('container').style.opacity = 1 - Math.min(1, (pathProgress - params.fadeStart) / (1 - params.fadeStart));
      document.getElementById('container').style.display = '';
      document.querySelectorAll('canvas').forEach(c => c.style.display = '');
    }
    renderer.setClearColor(0x000000, 0); // transparent
    scene.fog.density = params.fogDensity * (1 - Math.min(1, (pathProgress - params.fadeStart) / (1 - params.fadeStart)));
  } else {
    document.body.classList.remove('bg-end');
    document.getElementById('container').style.opacity = 1;
    document.getElementById('container').style.display = '';
    document.querySelectorAll('canvas').forEach(c => c.style.display = '');
    renderer.setClearColor(0x282828, 1); // or your default color
    scene.fog.density = params.fogDensity;
  }

  // Render with or without bloom based on settings
  if (params.useBloom) {
    composer.render();
  } else {
    renderer.render(scene, camera);
  }

  stats.end();
  animationFrameId = requestAnimationFrame(animate);

  const endScreen = document.getElementById('end-screen');
  if (pathProgress > 0.99) {
    endScreen.style.display = 'flex';
    document.getElementById('container').style.display = 'none';
    document.querySelectorAll('.narration-container, .title-container, .cta-btn').forEach(el => el.style.display = 'none');
  } else {
    endScreen.style.display = 'none';
    document.getElementById('container').style.display = '';
    document.querySelectorAll('.narration-container, .title-container, .cta-btn').forEach(el => el.style.display = '');
  }
}

// Apply color preset
function applyColorPreset(presetName) {
  if (!colorPresets[presetName]) return;

  // Update params with preset colors
  params.colorA = colorPresets[presetName].colorA;
  params.colorB = colorPresets[presetName].colorB;
  params.colorC = colorPresets[presetName].colorC;
  params.colorD = colorPresets[presetName].colorD;

  // Update Tweakpane UI
  colorInputs.forEach((input) => input.refresh());

  // Update lights to match first color
  light1.color.set(params.colorA);
  light2.color.set(params.colorB);

  // Rebuild tunnel with new colors
  createTunnel();
}

// Apply quality preset
function applyQualityPreset(preset) {
  switch (preset) {
    case "low":
      params.circleCount = 50;
      params.circleSegments = 48;
      params.tubeSegments = 6;
      params.particlesEnabled = false;
      params.useBloom = false;
      params.starCount = 1000;
      renderer.setPixelRatio(1);
      break;
    case "medium":
      params.circleCount = 80;
      params.circleSegments = 64;
      params.tubeSegments = 6;
      params.particlesEnabled = true;
      params.particleCount = 500;
      params.useBloom = true;
      params.starCount = 1500;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      break;
    case "high":
      params.circleCount = 100;
      params.circleSegments = 128;
      params.tubeSegments = 8;
      params.particlesEnabled = true;
      params.particleCount = 1000;
      params.useBloom = true;
      params.starCount = 2000;
      renderer.setPixelRatio(window.devicePixelRatio);
      break;
  }

  // Update UI
  pane.refresh();

  // Rebuild tunnel with new settings
  createTunnel();
}

// Setup Tweakpane
const pane = new Pane({
  container: document.getElementById("tweakpane-container")
});

// Function to save current values
function saveCurrentValues() {
  const currentValues = {};
  for (const key in params) {
    currentValues[key] = params[key];
  }
  console.log('Current Values:', currentValues);
  return currentValues;
}

// Add tabs
const tabs = pane.addTab({
  pages: [
    { title: "Presets" },
    { title: "Structure" },
    { title: "Appearance" },
    { title: "Effects" },
    { title: "Stars" },
    { title: "Movement" },
    { title: "Performance" },
    { title: "Title" },
    { title: "Narration" }
  ]
});

// Presets tab
const presetsTab = tabs.pages[0];

// Add save button at the top of presets tab
presetsTab.addButton({
  title: 'Save Current Values',
  label: 'SAVE CURRENT SETTINGS',
}).on('click', () => {
  // Get all current values
  const currentSettings = {
    // Structure
    tunnelDepth: params.tunnelDepth,
    circleCount: params.circleCount,
    tunnelRadius: params.tunnelRadius,
    tubeThickness: params.tubeThickness,
    circleSegments: params.circleSegments,
    tubeSegments: params.tubeSegments,
    pathAmplitude: params.pathAmplitude,

    // Appearance
    colorA: params.colorA,
    colorB: params.colorB,
    colorC: params.colorC,
    colorD: params.colorD,
    emission: params.emission,
    metalness: params.metalness,
    roughness: params.roughness,
    fogDensity: params.fogDensity,

    // Effects
    pulseSpeed: params.pulseSpeed,
    pulseIntensity: params.pulseIntensity,
    rotationSpeed: params.rotationSpeed,
    particlesEnabled: params.particlesEnabled,
    particleCount: params.particleCount,
    particleSize: params.particleSize,
    particleSpeed: params.particleSpeed,

    // Stars
    starsEnabled: params.starsEnabled,
    starCount: params.starCount,
    starSize: params.starSize,

    // Movement
    autoMovement: params.autoMovement,
    manualPosition: params.manualPosition,
    scrollSpeed: params.scrollSpeed,
    fadeStart: params.fadeStart,
    fadeIntensity: params.fadeIntensity,

    // Performance
    qualityPreset: params.qualityPreset,
    useBloom: params.useBloom,

    // Title settings
    titleShowThreshold: params.titleShowThreshold,
    titleHideThreshold: params.titleHideThreshold,

    // Narration settings
    narrationPoints: params.narrationPoints,
    narrationShowThreshold: params.narrationShowThreshold,
    narrationHideThreshold: params.narrationHideThreshold
  };

  // Log the current settings
  console.log('Current Settings:', JSON.stringify(currentSettings, null, 2));
  
  // Update the default parameters
  Object.assign(params, currentSettings);
  
  // Rebuild tunnel with new values
  createTunnel();
  
  // Show confirmation
  alert('Current settings have been saved as defaults!');
});

presetsTab
  .addBinding(params, "colorPreset", {
    options: {
      Default: "default",
      "Dark Abyss": "dark-abyss",
      "Neon Dreams": "neon-dreams",
      "Golden Hour": "golden-hour",
      "Deep Ocean": "deep-ocean",
      "Aurora Borealis": "aurora-borealis"
    }
  })
  .on("change", (ev) => {
    applyColorPreset(ev.value);
  });

// Structure tab
const structureTab = tabs.pages[1];
structureTab
  .addBinding(params, "circleCount", { min: 10, max: 120, step: 5 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "tunnelRadius", { min: 1, max: 10, step: 0.5 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "tubeThickness", { min: 0.02, max: 0.5, step: 0.01 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "circleSegments", { min: 12, max: 128, step: 4 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "tunnelDepth", { min: 50, max: 200, step: 10 })
  .on("change", () => createTunnel());
structureTab
  .addBinding(params, "pathAmplitude", { min: 0, max: 2, step: 0.1 })
  .on("change", () => createTunnel());

// Appearance tab
const appearanceTab = tabs.pages[2];
const colorInputs = [
  appearanceTab
    .addBinding(params, "colorA", { label: "Color 1 (Start)" })
    .on("change", () => createTunnel()),
  appearanceTab
    .addBinding(params, "colorB", { label: "Color 2 (25%)" })
    .on("change", () => createTunnel()),
  appearanceTab
    .addBinding(params, "colorC", { label: "Color 3 (50%)" })
    .on("change", () => createTunnel()),
  appearanceTab
    .addBinding(params, "colorD", { label: "Color 4 (75%)" })
    .on("change", () => createTunnel())
];

appearanceTab
  .addBinding(params, "emission", { min: 0, max: 1, step: 0.05 })
  .on("change", () => createTunnel());
appearanceTab
  .addBinding(params, "metalness", { min: 0, max: 1, step: 0.05 })
  .on("change", () => createTunnel());
appearanceTab
  .addBinding(params, "roughness", { min: 0, max: 1, step: 0.05 })
  .on("change", () => createTunnel());
appearanceTab
  .addBinding(params, "fogDensity", { min: 0, max: 0.1, step: 0.005 })
  .on("change", () => {
    scene.fog.density = params.fogDensity;
  });

// Effects tab
const effectsTab = tabs.pages[3];
effectsTab.addBinding(params, "pulseIntensity", { min: 0, max: 1, step: 0.05 });
effectsTab.addBinding(params, "pulseSpeed", { min: 0.1, max: 5, step: 0.1 });
effectsTab.addBinding(params, "rotationSpeed", {
  min: 0,
  max: 0.05,
  step: 0.001
});
effectsTab
  .addBinding(params, "particlesEnabled")
  .on("change", () => createTunnel());
effectsTab
  .addBinding(params, "particleCount", { min: 100, max: 1000, step: 50 })
  .on("change", () => createTunnel());
effectsTab
  .addBinding(params, "particleSize", { min: 0.01, max: 0.2, step: 0.01 })
  .on("change", () => createTunnel());
effectsTab.addBinding(params, "particleSpeed", {
  min: 0.1,
  max: 1.0,
  step: 0.1
});

// Stars tab
const starsTab = tabs.pages[4];
starsTab
  .addBinding(params, "starsEnabled")
  .on("change", () => createStarField());
starsTab
  .addBinding(params, "starCount", { min: 500, max: 3000, step: 100 })
  .on("change", () => createStarField());
starsTab
  .addBinding(params, "starSize", { min: 0.01, max: 0.2, step: 0.01 })
  .on("change", () => createStarField());

// Movement tab
const movementTab = tabs.pages[5];
movementTab.addBinding(params, "autoMovement").on("change", (ev) => {
  // Show/hide manual position slider based on auto movement setting
  manualPositionInput.hidden = ev.value;
});
const manualPositionInput = movementTab.addBinding(params, "manualPosition", {
  min: 0,
  max: 0.99,
  step: 0.01
});
// Initially hide manual position if auto movement is enabled
manualPositionInput.hidden = params.autoMovement;

movementTab.addBinding(params, "scrollSpeed", {
  min: 0.1,
  max: 2.0,
  step: 0.1
});
movementTab.addBinding(params, "fadeStart", {
  min: 0.5,
  max: 0.95,
  step: 0.05
});
movementTab.addBinding(params, "fadeIntensity", { min: 1, max: 5, step: 0.5 });

// Performance tab
const performanceTab = tabs.pages[6];
performanceTab
  .addBinding(params, "qualityPreset", {
    options: {
      Low: "low",
      Medium: "medium",
      High: "high"
    }
  })
  .on("change", (ev) => {
    applyQualityPreset(ev.value);
  });

performanceTab.addBinding(params, "useBloom").on("change", () => {
  // No need to rebuild tunnel, just toggle bloom effect
});

// Title tab - for controlling title settings
const titleTab = tabs.pages[7];
titleTab.addBinding(params, "titleShowThreshold", {
  min: 0.5,
  max: 0.99,
  step: 0.01,
  label: "Show at"
});
titleTab
  .addBinding(params, "titleHideThreshold", {
    min: 0.5,
    max: 0.99,
    step: 0.01,
    label: "Hide at"
  })
  .on("change", () => {
    // Ensure hide threshold is less than show threshold
    if (params.titleHideThreshold >= params.titleShowThreshold) {
      params.titleHideThreshold = params.titleShowThreshold - 0.02;
      pane.refresh();
    }
  });

// Narration tab
const narrationTab = tabs.pages[8];
narrationTab.addBinding(params, "narrationShowThreshold", {
  min: 0.01,
  max: 0.99,
  step: 0.01,
  label: "Show at"
});
narrationTab
  .addBinding(params, "narrationHideThreshold", {
    min: 0.01,
    max: 0.99,
    step: 0.01,
    label: "Hide at"
  })
  .on("change", () => {
    // Ensure hide threshold is less than show threshold
    if (params.narrationHideThreshold >= params.narrationShowThreshold) {
      params.narrationHideThreshold = params.narrationShowThreshold - 0.02;
      pane.refresh();
    }
  });

// Handle resize
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});

// Start animation
animate();

  </script>

  <!-- Add this just after <body> -->
  <div id="end-screen" style="
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: url('https://images.unsplash.com/photo-1624269636254-c4dc6c1d0e44?q=80&w=2684&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D') center center / contain no-repeat #000;
    z-index: 99999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  "></div>
</body>
</html>
